
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage[latin1]{inputenx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage{schemata}
\usepackage{mathtools}
\usepackage{listings}
\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
DOBLE GRADO INGENIERÍA DEL SOFTWARE Y MATEMÁTICAS

\vspace{0.4cm}

\large
Curso Académico 2019/2020

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
Criptografía sobre curvas elípticas. Cifrado basado en identidades.

\vspace{4cm}

\large
Autor : José Francisco Rodríguez Peña \\
Tutor : Ángel Luis Pérez del Pozo
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Objetivo}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{OBJETIVO}{OBJETIVO} % encabezado
El objetivo de este trabajo es tener un primer contacto con el estudio de la criptografía, haciendo énfasis en la criptografía de clave pública y la teoría necesaria para definir la criptografía sobre curva elíptica. Finalmente se estudiará un esquema de cifrado basado en identidades sobre curvas elípticas.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
%\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
La criptografía es el estudio y las técnicas para tratar la información de manera segura en presencia de adversarios. Para conseguir ese objetivo podemos tener en cuenta cuatro puntos fundamentales para tratamiento de la información:
\begin{itemize}
\item Confidencialidad: La información no puede ser accedida por miembros externos al grupo destinado a tratar la información.
\item Integridad: La información no puede ser modificada en ningún punto de su ciclo de vida.
\item Autenticidad: El origen de la información debe ser contrastable.
\item No repudio: El origen de la información no puede negar que la información fue originada por él.
\end{itemize} 
Dentro de este marco, vamos a centrarnos en el cifrado de datos. Para esto se hace uso de alguna transformación del mensaje de forma que no pueda ser recuperada ninguna información útil y que solo los receptores legítimos del mensaje puedan volver a transformarlo en el mensaje original, estas transformaciones son llamadas \textit{cifrado} y \textit{descifrado} respectivamente.\\
Las primeras técnicas para cifrar mensajes consistían en sustituir todas las letras del mensaje mediante alguna tabla o relación, en concreto en el cifrado César se alternaban por su correspondiente en el alfabeto desplazada un número de posiciones, este número era la clave del cifrado y para descifrar bastaba con realizar el mismo desplazamiento en sentido inverso, dada la poca cantidad de claves posibles para este cifrado es muy fácil de romper por fuerza bruta, sin embargo una de las formas más ingeniosas para romperlo consiste en analizar la distribución de letras en el idioma del mensaje y, si este es suficientemente largo, se puede detectar el desplazamiento en esa distribución.\\
\begin{figure}[H]
\includegraphics[scale=0.4]{img/Caesar3.png}\\
\caption{Cifrado César}
\end{figure}
En el siglo XV aparece el cifrado Vigènere que consistía en una palabra clave que se usaba para desplazar las letras del mensaje, por ejemplo si la clave es 'ABC' los desplazamientos serían 1, 2 y 3 posiciones respectivamente, y se repetía esta clave hasta acabar por completo el mensaje.\\
La criptografía estuvo ligada fuertemente al uso militar y durante los siglos XIX y XX tuvo una importancia fundamental con la máquina Enigma, en este periodo de tiempo se invirtió un gran esfuerzo en desarrollar este área dando lugar a grandes avances.\\
Posteriormente a la Segunda Guerra Mundial se realizaron muchos estudios teóricos y en los años 70 se crearon algunos estándares de algoritmos de cifrado, a partir de entonces, con la evolución de la informática existe una actualización constante de algoritmos cada vez mas seguros ya que la capacidad de cómputo es mayor.\\
Es habitual agrupar los algoritmos según la naturaleza de las claves que son necesarias al cifrar y descifrar:
\begin{itemize}
\item Criptografía simétrica: Estos métodos utilizan la misma clave para cifrar y descifrar mensajes, las distintas partes que intercambian información deben conocer esta clave de antemano, existen distintos algoritmos que ponen esto en practica, uno de los mas conocidos entre los métodos recientes es DES (Data Encryption Standard), diseñado en los años 70 y reemplazado a día de hoy por AES (Advanced Encryption Standard).
\item Ciptografía asimétrica: También conocida como criptografía de clave pública, se basa en un par de claves, una pública que se debe dejar a disposición de cualquiera y una privada que se debe mantener en secreto. Este tipo de métodos son utilizados, entre otras cosas, para el cifrado basado en identidad y el cifrado basado en certificados.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DESARROLLO %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Herramientas matemáticas}
En este apartado se presentan una serie de conceptos y algoritmos necesarios para poder entender el origen de la seguridad de los diferentes esquemas, así como su implementación.
\section{Grupo}
Dado un conjunto no vacío de elementos $G$ y una operación $\cdot$ que combina un par de elementos en un tercero, se define grupo al par ($G$,$\cdot$) donde se cumplen las siguientes propiedades:
\begin{itemize}
\item Clausura: $\forall a,b \in G$ se tiene que $a\cdot b\in G$ .
\item Asociatividad: $\forall a,b,c \in G$ se tiene que $a\cdot(b\cdot c) =(a\cdot b)\cdot c$ .
\item Elemento neutro: $\exists e\in G$ tal que $\forall a\in G$ se cumple $a\cdot e =e\cdot a = a$ . Cuando la operación es la multiplicación se denota este elemento como $1$ y cuando es la suma se denota como $0$.
\item Elemento inverso: $\forall a\in G,\ \exists a^{-1}\in G$ elemento inverso de $a$ tal que $a \cdot a^{-1}=e$ . Cuando la operación es la suma $+$ se suele denotar al elemento inverso como $-a$ .
\end{itemize}
Se denomina grupo abeliano si además de esto se cumple la propiedad conmutativa:\\
$\forall a,b\in G$ se cumple que $a\cdot b = b\cdot a$ .\\
Es habitual que los grupos abelianos usen notación aditiva $+$.

\section{Grupo cíclico}
Sea $G$ un grupo, se dice que $G$ es un \textit{grupo cíclico} si existe un elemento del grupo $g\in G$ de forma que $G=\left\langle g \right\rangle$, es decir, cualquier elemento del grupo puede expresarse como $g^n$ (o $ng$ si es un grupo aditivo) para algún $n\in\mathbb{Z}$, llamamos entonces a $g$ \textit{generador} de $G$.
Un ejemplo habitual de grupo cíclico es el grupo aditivo de los números enteros módulo $n$, denotado habitualmente como $\mathbb{Z}/n\mathbb{Z}$, tomando como generador el $1$.\\
\underline{Lema}: Cada grupo cíclico finito de orden $n$ es isomorfo al grupo $\mathbb{Z}/n\mathbb{Z}$.

\section{Logaritmo discreto}
\label{chap:logaritmo discreto}
Para algunos algoritmos de criptografía necesitamos una función que sea fácil de aplicar pero difícil de invertir a nivel de tiempo de cómputo, por ello vamos a ver el caso del logaritmo discreto.\\
Dado un grupo cíclico finito $G$ con base $g$, definimos el logaritmo discreto como:
\[
y=g^x \Longleftrightarrow x =\log_{g}(y)
\]
Por un lado tenemos la \textit{exponenciación discreta}, es decir, $g^x$ cuando $x$ es conocido, esta operación se puede calcular con el algoritmo recursivo de exponenciación binaria, con complejidad $\cal{O} $($\log x$).\\
No obstante el problema de calcular $x =\log_{g}(y)$ es más difícil, el algoritmo Baby-step/Giant-step tiene complejidad $\cal{O} $($\sqrt{p}$), asumiendo que el grupo tiene orden primo $p$.
\section{Exponenciación binaria}
Para calcular $g^x$, tenemos que hacer la operación recursiva $F$ definida de la siguiente forma:\\
\schema{\schemabox{$F(g^x)= $}}{
\schemabox{
$g$ si $n=1$\\
$\left( F(g^\frac{x}{2}) \right)^2$ si $x$ es par\\
$F(g^{(x-1)})\cdot g$ si $x$ es impar
}
}\\
Puesto que en cada operación reducimos el exponente $x$ a la mitad, tenemos que realizar 
$\ceil{\log_{2}(x)}$ operaciones, por tanto este problema se puede resolver en $\cal{O} $($\log x$).\\

\section{Algoritmo Baby-step/Giant-step}
Queremos conocer $x$ en la ecuación $h=g^x$, sea $p$ el orden del grupo $G$.\\
Descompondremos nuestra solución en:
\[
x=x_0+x_1\ceil*{\sqrt{p}}
\]
Puesto que $x<p$, entonces $0\leq x_0,x_1<\ceil*{\sqrt{p}}$.\\
En primer lugar calcularemos los \textit{baby-step}, esto es:
\[
g_i=g^i\ t.q.\ 0\leq i<\ceil*{\sqrt{p}}
\]
Tras ello calcularemos los \textit{giant-step}, esto es:
\[
h_j=hg^{-j\ceil*{\sqrt{p}}}\ t.q.\ 0<j<\ceil*{\sqrt{p}}
\]
Una forma eficiente de almacenar estos resultados es con una tabla hash almacenando los pares $(i,g_i)$ y $(h_j,j)$ respectivamente.\\
Ahora intentamos encontrar una coincidencia tal que $g_i=h_j$, si esto ocurre tenemos que:
\[
x_0=i, x_1=j
\]
Ya que
\[
g^i=hg^{-j\ceil*{\sqrt{p}}}\Rightarrow g^{i+j\ceil*{\sqrt{p}}}=h
\]
Dado que para calcular los \textit{baby-step} y los \textit{giant-step} son necesarias como mucho $2\ceil*{\sqrt{p}}$ operaciones, y para buscar una coincidencia solo es necesario tener almacenados los pares (clave,valor) de forma $(i,g_i)$ y $(h_j,j)$ para ver si existe la clave $g_i$ en el segundo hash map, por tanto encontrando una coincidencia, puesto que comprobar una clave es $\cal{O}$(1) y  se recorren únicamente los $g_i$ tenemos de nuevo $\ceil*{\sqrt{p}}$ operaciones, por lo que este algoritmo es de complejidad  $\cal{O} $($\sqrt{p}$).


\cleardoublepage
\chapter{Curvas elípticas} % título del capítulo (se muestra)
En este capítulo se presenta la base de la criptografía sobre curvas elípticas, como hemos visto el problema en el que se va a basar la seguridad de los algoritmos es el logaritmo discreto, este requiere de un grupo cíclico, para ello vamos a utilizar el grupo formado por las curvas elípticas con su operación de suma de puntos que veremos a continuación.
\label{chap:curvas-elipticas} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Definiciones} % título de sección (se muestra)
\label{sec:def-curva-eliptica} % identificador de sección (no se muestra, es para poder referenciarla)
\subsection{Plano proyectivo}
Sea $K$ un cuerpo, \textit{el plano proyectivo} $\mathbb{P}^2(K)$ definido sobre $K$ son la tripletas:
\[(X,Y,Z)\ t.q.\ X,Y,Z\in K\]
donde $X,Y,Z$ no son simultáneamente 0 y definimos la relación de equivalencia:
\[ Eq: (X,Y,Z)\equiv(X',Y'.Z') \Longleftrightarrow \exists \lambda \in K\ t.q.\ X=\lambda X',\ Y=\lambda Y',\ Z=\lambda Z' \]
Se define \textit{el plano proyectivo} sobre el cuerpo $K$ como:
\[
\mathbb{P}^2(K) = \dfrac{K^3}{Eq}
\]
\subsection{Curva elíptica}
Una \textit{curva elíptica} se define sobre el conjunto de soluciones de la ecuación Weierstrass homogénea de la forma:
\begin{equation} 
E:\ Y^2Z + a_1XYZ + a_3YZ^2 = X^3 + a_2X^2Z + a_4XZ^2 + a_6Z^3 \label{eq:proy-eliptic}
\end{equation}
donde $a_1,a_2,a_3,a_4,a_6\in K$, esta notación es conocida como forma larga Weierstrass. Dicha curva debe ser no singular, es decir, si la escribimos de la forma $F(X,Y,Z)=0$, las derivadas parciales no deben ser cero simultáneamente en ningún punto de la curva.
El conjunto de los \textit{puntos K-racionales} en $E$ son la solución de la ecuación \ref{eq:proy-eliptic} y lo denotaremos $E(K)$. Destacar que la curva tiene exactamente un punto racional con coordenada $Z$ igual a cero, el $(0,1,0)$, este es el punto en el infinito y lo denotaremos como $\cal{O}$.\\
\underline{Nota:}\\
Esta representación de la curva permite realizar operaciones de forma eficiente, esto puede verse en \cite[pag. 31-32]{Nigel}.
\section{Paso al plano afín}
Si tomamos la ecuación \ref{eq:proy-eliptic} y definimos el cambio de forma que:
\begin{itemize}
\item El punto $\cal{O}$ se toma como el infinito en cualquier dirección en $K^2$.
\item Un punto en el plano proyectivo con $Z\not= 0$ como $\left(\dfrac{X}{Z},\dfrac{Y}{Z}\right)$ en $K^2$.
\item Para volver al plano proyectivo se toma cualquier $Z\in K$ y se calcula  $\left( X\cdot Z,Y\cdot Z, Z\right)$.
\end{itemize}
Con este cambio la curva queda definida por:
\begin{equation}
E:\ Y^2 + a_1 XY + a_3 Y = X^3 + a_2 X^2 + a_4 X + a_6  \label{eq:afin-eliptic}
\end{equation}
con $a_1,a_2,a_3,a_4,a_6 \in K$

Es posible demostrar (se demuestra en \cite[pag. 25-26]{Nigel}) que dada cualquier curva de la forma \ref{eq:afin-eliptic}, existe un isomorfismo a la curva que llamaremos \textit{forma corta Weierstrass}:
\begin{equation}
E:\ Y^2 = X^3 + aX + b
\end{equation}
donde $a,b\in K$

\section{Ley de grupo}

Definimos la \textit{suma de puntos}, sea $P,Q \in E$, entonces:
\begin{itemize}
\item Se toma la recta que une $P$ y $Q$.
\item Se calcula el punto de corte de la recta y la curva $E$ al que llamaremos $R$.
\item $P+Q$ se define como el simétrico de $R$ respecto al eje x.
\end{itemize}
\begin{figure}[H]
\includegraphics[scale=1]{img/Curva.png}
\caption{Suma de puntos}
\label{Suma de puntos}
\end{figure}
\underline{Observación:}\\
$\left[2\right]P=P+P$ se calcula usando la recta tangente a la curva en el punto $P$, por lo que si la tangente es una recta vertical se considera que $P+P=\cal{O}$.\\

De manera algebraica definimos la \textit{suma de puntos} como:

Sea la curva de la forma
\[E:\ Y^2 + a_1 XY + a_3 Y = X^3 + a_2 X^2 + a_4 X + a_6 \]
y los puntos de la curva $P_1=(x_1,y_1), P_2=(x_2,y_2)$. Entonces $-P_1=(x_1,-y_1-a_1x_1-a_3)$.
Tomamos $\lambda$,$\mu$ :\\
\schema{\schemabox{}}{
\schemabox{
$x_1\not=x_2$  \schema{\schemabox{}}{\schemabox{$\lambda=\dfrac{y_2-y_1}{x_2-x_1}$\\$ \mu=\dfrac{y_1x_2-y_2x_1}{x_2-x_1}$}}\\
$x_1=x_2,P_2\not=P_1$  \schema{\schemabox{}}{{\schemabox{$\lambda=\dfrac{3x_1^2+2a_2x_1+a_4-a_1y_1}{2y_1+a_1x_1+a_3}$\\$ \mu=\dfrac{-x_1^3+a_4x_1+2a_6-a_3y_1}{2y_1+a_1x_1+a_3}$}}}
}
}\\

Entonces si $P_3=(x_3,y_3)=P_1+P_2\not=\cal{O}$ se puede calcular $x_3$ e $y_3$ como:
\begin{equation*}
\begin{split}
x_3&=\lambda^2+a_1\lambda-a_2-x_1-x_2,\\
y_3&=-(\lambda+a_1)x_3-\mu-a_3
\end{split}
\end{equation*}

\underline{Nota:}\\
Para un entero positivo $m$ tenemos que $\left[m\right] $ denota la aplicación de la \textit{multiplicación-por-m} de la curva en si misma.
Esta aplicación lleva un punto $P$ a $\underbrace{P+P+...+P}_{m\ veces}$.\\
Esta aplicación será la base de la criptografía sobre curvas elípticas ya que se considera fácil de computar pero difícil de invertir como hemos visto en el capítulo \ref{chap:logaritmo discreto}.

\section{Curvas elípticas sobre cuerpos finitos}
Sobre un cuerpo finito $\mathbb{F}_q$ el número de puntos racionales de la curva es finito y queda determinado por:
\[
\#E(\mathbb{F}_q)=q+1-t
\]
Donde $t$ se conoce como la traza de Frobenius.\\
\underline{Teorema de Hasse}: $t$ cumple que $|t|<2\sqrt{q}$.\\
La aplicación $q^{th}$-potencia de Frobenius de la curva $E$ definida sobre $\mathbb{F}_q$ es:\\
\schema{\schemabox{$\varphi$}}{\schemabox{$E(\overline{\mathbb{F}_q})\rightarrow E(\overline{\mathbb{F}_q})$\\$(x,y)\rightarrow (x^q,y^q)$\\$\cal{O}\rightarrow \cal{O}$}}\\
Esta aplicación es un endomorfismo que respeta la operación de la ley de grupo $\varphi (P+Q)=\varphi (P)+\varphi (Q)$\\
\section{Compresión de punto}
Para transmitir la información de un punto en una curva elíptica en el plano afín se podría enviar las coordenadas $x$ e $y$ del punto, pero esto puede mejorarse si nos damos cuenta que para cada coordenada $x$ solo hay dos posibles valores en la curva de la coordenada $y$, por lo que solo es necesario indicar cual debemos tomar, reduciendo nuestra representación a la mitad más un bit del tamaño original.\\
\underline{Demostración}:\\
Para una curva elíptica sobre un cuerpo finito $\mathbb{F}^*_p$ con $p$ un número primo grande, tomamos $\alpha \in \mathbb{F}^*_p$.\\
Ahora bien, siendo $\pm \beta$ las raíces cuadradas de $\alpha$, estas tienen distinta paridad, ya que $-\beta = p - \beta$. Por tanto podemos reconstruir cualquier punto de la curva indicando con un bit $b$ la paridad de $y$.\\
Computamos $\beta = \sqrt{x^3+ax+b}$  $(mod\ p)$. Si la paridad de $\beta$ y $b$ coinciden asignamos $y = \beta$, en caso contrario asignamos $y = p-\beta$. Si $\beta = 0$ asignamos $y=0$ sin importar $b$.



\cleardoublepage
\chapter{Clave pública}
Los esquemas de clave pública se basan en una pareja de claves (clave pública, clave privada), estas claves a diferencia de la criptografía simétrica requieren de su pareja para realizar la operación inversa.\\
Existen dos usos fundamentales de este tipo de esquemas, el primero donde dos extremos quieren intercambiar información, el emisor usará la clave pública del receptor para cifrar el mensaje y enviarlo, el receptor al ser el único conocedor de su clave privada puede recuperar el mensaje original, el segundo caso donde el emisor hace uso de su clave privada y el mensaje para que cualquier receptor pueda validar la identidad del emisor y la integridad del mensaje haciendo uso de la clave pública del emisor, este caso es el que se conoce como \textit{firma digital}.

\section{Intercambio de claves Diffie-Hellman}
En algunos algoritmos es necesario que partes no autentificadas lleguen a intercambiar claves por un canal no seguro, esto supuso un problema que solventaron Whitfield Diffie y Martin Hellman con su protocolo, se utiliza para acordar claves simétricas en una sesión y esto posteriormente permite los protocolos de comunicación autentificada. Su seguridad tiene origen en el problema del logaritmo discreto ya que, como hemos visto antes en el capítulo\ref{chap:logaritmo discreto}, es fácil de computar y difícil de invertir.\\
Supongamos que tenemos dos usuarios finales que quieren comunicarse entre sí, sean estos Alice y Bob, el protocolo Difie-Hellman en una versión simple sigue los siguientes pasos:
\begin{itemize}
\item Fijar un primo $p$ y un generador del grupo $g\in \mathbb{Z}^*_p$. Estos valores son conocidos para cualquiera que tenga acceso al canal donde se intercambian.
\item Alice elige un $a\in \mathbb{Z}_{p-1}$, computa $A = g^a\ mod\ p$ y lo envía a Bob.
\item Bob elige un $b\in \mathbb{Z}_{p-1}$, computa $B = g^b\ mod\ p$ y lo envía a Alice.
\end{itemize}
Con esta información ambos extremos son capaces de computar $K = (g)^{ab}\ mod\ p$, ya que Alice puede calcular $K = B^a\ mod\ p$ y Bob $K = A^b\ mod\ p$. Se utilizará $K$ como la clave compartida.\\

\begin{figure}[H]
\includegraphics[scale=0.45]{img/Diffie-Hellman.png}
\caption{Intercambio de claves Diffie-Hellman}
\end{figure}
No obstante cualquier atacante que quiera conocer la clave $K$ en el canal solo tiene acceso a $g,p,A$ y $B$, por lo que para computar la clave tiene que calcular $a=log_p(A)$ y $b=log_p(B)$ siendo este el logaritmo discreto.\\
Existen ataques a este protocolo que no están basados en resolver el logaritmo discreto sino en aprovechar que las partes no están autentificadas y por tanto hacer creer a ambos que él es el otro extremo, esto es conocido como \textit{Man-in-the-middle}.\\
De la misma forma que se aplica este protocolo en su versión original es posible aplicarla sobre el grupo aditivo de las curvas elípticas, este protocolo es conocido como EC-DH y una de las ventajas que nos proporciona es que utilizando la compresión de punto se puede reducir la cantidad de información necesaria para realizar el protocolo con la misma seguridad, reduciendo el ancho de banda y mejorando el rendimiento. Curve25519 es una curva elíptica conocida por ofrecer buen rendimiento.

\section{Funciones Hash}
Hasta este punto hemos visto como se puede mantener la confidencialidad de un mensaje para que cualquier atacante no pueda obtener la información aún teniendo acceso al canal por el que se transmite, no obstante debemos tener en cuenta el escenario donde el atacante manipula el mensaje, por tanto debemos preocuparnos de la integridad, para comprobar que un mensaje no ha sido modificado es habitual hacer uso de \textit{funciones hash}.\\
Una \textit{funcion hash} es una aplicación que lleva una cadena de bits de cualquier longitud a una cadena de bits de longitud fija. Estas funciones tienen una serie de propiedades deseables, si tenemos la función hash $h(x)=y$ ,sus propiedades deberían ser:
\begin{itemize}
\item Resistencia a la preimagen: debe ser difícil a efectos prácticos que conociendo $y$ se pueda calcular $x$.
\item Resistencia a colisiones: debe ser difícil encontrar dos valores $x$ y $x'$ tal que $h(x)=h(x')$ pero $x\not=x'$.
\item Resistencia a la segunda preimagen: dado un $x$ debe ser difícil encontrar otro $x'$ tal que $h(x)=h(x')$ pero $x\not=x'$.
\end{itemize}
Más adelante veremos como estas funciones son necesarias a la hora de comprobar la integridad de la información, ya que cualquier pequeña modificación en el mensaje se reflejaría al calcular el hash del mismo.

\section{Cifrado de clave pública}
Para poder realizar el cifrado de clave pública se deben llevar a cabo varias etapas con la que se pueden definir los distintos algoritmos:
\begin{itemize}
\item Generación de claves: En primer lugar se debe acometer la tarea de generar las claves necesarias para el cifrado, estas están basadas en algún problema matemático complejo de invertir, el resultado de esta etapa debe ser la clave privada, que debe ser conocida únicamente por el receptor del mensaje, y la clave pública que debe dejarse a disposición de cualquiera ya que esto no debe comprometer la seguridad del sistema.
\item Cifrado: Una vez un emisor desea enviar un mensaje, debe hacer uso de la clave pública del receptor para transformar el mensaje como indique el esquema correspondiente para posteriormente enviarlo.
\item Descifrado: Cuando un receptor ha recibido un mensaje debe hacer uso de su clave privada, que es conocida únicamente por él, para recuperar el mensaje original por medio de las transformaciones que requiera el esquema correspondiente sin que nadie haya podido modificarlo ni leerlo.
\end{itemize}
Esto a priori no garantiza la auntenticidad del emisor, no obstante veremos como se solventa este problema en el siguiente apartado.\\
Se denomina \textit{correción} de un esquema a la propiedad de poder recuperar el mensaje original aplicando el descifrado sobre el mensaje cifrado sin intervención del adversario.
\subsection{Ejemplo: Cifrado RSA} \label{Cifrado RSA}
Como ejemplo de esquema de clave pública vamos a analizar RSA, nombrado así por sus creadores Rivest, Shamir y Adleman, ya que es uno de los primeros ,originado en 1979, y además es uno de los algoritmos más usados tanto para cifrar como para firmar digitalmente.\\

En primer lugar analicemos en que consiste el algoritmo aplicado al cifrado de mensajes entre extremos.\\
Supongamos dos usuarios finales Alice y Bob. Bob quiere enviar un mensaje a Alice y para ello se va a usar el algoritmo RSA, este consiste en:
\begin{itemize}
\item Generación de claves:
\begin{itemize}

\item Alice elige dos números primos grandes $p$ y $q$ y calcula $N=p\cdot q$.
\item Alice elige un exponente $e$ de forma que $mcd(e,(p-1)\cdot (q-1))=1$.
\item En el calculo del exponente para descifrar, Alice usa el algoritmo de Euclides extendido para conocer $d$ en la ecuación:
\begin{equation}
e\cdot d \equiv 1\ mod\ (p-1)(q-1)\label{eq:congruentes}
\end{equation}
\end{itemize}

\end{itemize}
En este punto la clave pública de Alice es el par $(N,e)$ y su clave privada es la tripleta $(d,p,q)$. Por tanto para intercambiar el mensaje se realizan los siguientes pasos:

\begin{itemize}
\item Cifrado:
\begin{itemize}
\item Bob quiere mandar su mensaje $m$, por lo que cifra el mensaje para obtener $c$ calculando $c=m^e\ mod\ N$.
\end{itemize}
\item Descifrado:
\begin{itemize}
\item Alice recibe $c$ por lo que para poder leer el mensaje tiene que calcular $m$ de la forma $m=c^d\ mod\ N$.
\end{itemize}
\end{itemize}

\underline{Demostración}: Corrección del esquema\\
Queremos demostrar que $m=c^d\ mod\ N$. \\
El orden del grupo $(\mathbb{Z}/N\mathbb{Z})^*$ viene dado por $\phi(N)=(q-1)(p-1)$, por tanto:
\begin{equation}
\forall x\in(\mathbb{Z}/N\mathbb{Z})^*: \ x^{(q-1)(p-1)}\equiv 1\ mod\ N\label{reducir}
\end{equation}
Ahora bien, para algún entero $s$ se tiene que $ed-s(q-1)(p-1)=1$ puesto que se cumple la ecuación \ref{eq:congruentes}. Por tanto:\\
\[
\begin{split}
c^d&=m^{ed}\ mod\ N\\
&=m^{1+s(q-1)(p-1)}\ mod\ N\\
&=m\cdot m^{s(q-1)(p-1)}\ mod\ N\\
&=m\ mod\ N
\end{split}
\]\\
Como queríamos demostrar.\\

\underline{Nota}: La seguridad de este algoritmo reside en el problema de factorización, ya que si logramos factorizar $N$ como $p\cdot q$ entonces podremos calcular $d$, no obstante este problema se considera complejo a nivel de cómputo.

\section{Firma digital}
La firma digital es un mecanismo que se usa para verificar el origen de un mensaje, es decir, asegura  la autenticación del emisor y el no repudio, además permite también verificar la integridad del mensaje.\\
Para logar este objetivo se llevan a cabo diferentes etapas que definen los diferentes esquemas, estas son:
\begin{itemize}
\item Generación de claves: Al igual que en el cifrado, se debe acometer la tarea de generar las claves necesarias para la firma digital, estas están basadas en algún problema matemático complejo de invertir, el resultado de esta etapa debe ser la clave privada, que debe ser conocida únicamente por el receptor del mensaje, y la clave pública que debe dejarse a disposición de cualquiera ya que esto no debe comprometer la seguridad del sistema.
\item Firma: Cuando un emisor desea firmar un mensaje, debe hacer uso de la clave privada de la forma que indique el algoritmo para dejar una información a la que llamamos \textit{firma} y que enviaremos junto al mensaje.
\item Verificación: Haciendo uso del mensaje recibido, la firma y la clave pública del emisor, el receptor puede verificar la autenticidad, integridad y no repudio del mensaje mediante los pasos que se detallen en el algoritmo.
\end{itemize}

\subsection{Ejemplo: Firma digital con RSA}
Existen varias implementaciones diferentes de este mecanismo, pero en este caso nos vamos a centrar en la firma con RSA.\\
Supongamos dos usuarios finales Alice y Bob, Alice quiere enviar un mensaje a Bob, pero Bob tiene que poder asegurarse que el mensaje procede de Alice y nadie lo ha modificado, para ello van a usar la firma digital:

\begin{itemize}
\item Generación de claves: De la misma forma que se genera en la sección \ref{Cifrado RSA}, Alice genera su clave privada $(N,e)$ y su clave pública $(d,p,q)$.\\
\item Firma:
\begin{itemize}
\item Alice aplica una función hash $h$ al mensaje $m$, quedandose con $r_s=h(m)$.
\item Alice usa su clave privada $(d,p,q)$ para cifrar $r_s$, esta será la firma del mensaje $S=r_s^d\ mod\ p\cdot q$.
\item Alice envía el mensaje, que no tiene porque estar cifrado, junto con la firma a Bob.
\end{itemize}
\item Verificación:
\begin{itemize}
\item Bob recibe el mensaje y la firma de Alice y usa la firma para calcular $r_s=S^e\ mod\ N$ con la clave pública de Alice $(e,N)$.
\item Bob aplica la misma función hash que Alice al mensaje $r_m=h(m)$.
\item Si $r_s=r_m$ entonces el mensaje queda verificado.
\end{itemize}
\end{itemize}
Dado que Alice tuvo que usar su clave privada para cifrar la firma, no es posible modificar la firma $S$ sin que invalide la verificación, de la misma forma que ocurre en el mensaje ya que no podrías cifrar el nuevo hash.

\cleardoublepage
\chapter{Cifrado basado en identidad}
El cifrado basado en identidad es un esquema de clave pública donde la clave de un usuario se obtiene a partir de una información que lo identifique, ya sea su email, número de teléfono, etc...\\
Este esquema necesita de un generador de claves privadas (PKG), este provee a los usuarios de su clave privada y les da la forma de conocer la clave pública de los demás usuarios a partir de su identidad, el proceso que realiza un usuario final para conocer su clave privada y la clave pública de los demás solo se necesita aplicar una vez. \\
Si dos usuarios finales quieren intercambiar un mensaje, por ejemplo Alice quiere enviar un mensaje a Bob, entonces Alice usa la clave pública maestra con la identidad de Bob para cifrar el mensaje y lo envía, luego Bob usará su clave privada para descifrar el mensaje, como queda representado en el siguiente diagrama.\\
\begin{figure}[H]
\includegraphics[scale=0.6]{img/Identity_Based_Encryption.png}
\caption{Cifrado basado en identidad}
\end{figure}

\section{Emparejamiento}
Dados dos grupos cíclicos aditivos $G_1, G_2$ de orden primo $p$ y un grupo cíclico $G_T$ escrito multiplicativamente, un \textit{emparejamiento} es una aplicación $e: G_1 \times G_2\ \rightarrow\ G_T$ que cumple:
\begin{itemize}
\item Bilinearidad:
\[
\forall a,b \in F^*_p, \forall P\in G_1, \forall Q\in G_2: e(aP,bQ)=e(P,Q)^{ab}
\]
\item No degenerado:
\begin{equation*}
\begin{split}
&\forall P\in G_1\ P\not=0, \exists Q\in G_2\ t.q.\ e(P,Q)\not=1\\
&\forall Q\in G_2\ Q\not=0, \exists P\in G_1\ t.q.\ e(P,Q)\not=1
\end{split}
\end{equation*}
\item Computable: existe un algoritmo eficiente para computar $e$.
\end{itemize}

\section{Esquema basado en emparejamiento}
En este punto tenemos los conceptos necesarios para plantear el esquema propuesto en el artículo original de Dan Boneh y Matthew Franklin sobre cifrado basado en identidad usando Weil pairing \cite{Boneh}.\\
\subsection{Preparación}
Para poder tener los elementos necesarios del cifrado basado en identidad, necesitamos un paso previo de selección de parámetros para el algoritmo.
Sea $\cal{G}$ un generador de parámetros para el problema Diffie-Hellman Bilineal \cite[pag. 7-9]{Boneh}.\\
Dado un parámetro de seguridad $k \in \mathbb{Z}^+$, se realizan los siguientes pasos:\\

\begin{itemize}
\item Paso 1: Ejecutar $\cal{G}$ con el parámetro $k$ para obtener un primo $q$, dos grupos $G_1$ y $G_2$ de orden $q$ y un emparejamiento válido $e: G_1 \times G_1\ \rightarrow\ G_2$. Elegir al azar un generador $P \in G_1$.\\
\underline{Nota}: $G_1$ es elegido como un subgrupo de $E(\mathbb{F}_p)$, en concreto el subgrupo generado por $P\in E(\mathbb{F}_p)$ de orden $q$. Por otro lado $G_2$ es el subgrupo de $\mathbb{F}^*_{p^2}$ de orden $q$.

\item Paso 2: Elegir al azar $s \in \mathbb{Z}^*_q$ y tomar $P_{pub} = sP$. La clave maestra será $s$.
\item Paso 3: Elegir las funciones criptográficas:
\[
\begin{split}
&H_1: \lbrace 0,1\rbrace^*\ \rightarrow\ G^*_1\\
&H_2: G^*_2\ \rightarrow\  \lbrace 0,1\rbrace^n
\end{split}
\]
\end{itemize}
El espacio de mensajes es $\cal{M} =$ $\lbrace 0,1 \rbrace^n$, el espacio de texto cifrado es $\cal{C} =$ $G_1^* \times \lbrace 0,1 \rbrace^n$.\\
Los parámetros para el sistema son $\langle q,G_1,G_2,e,n,P,P_{pub},H_1,H_2\rangle$, junto con la clave maestra $s$.
\subsection{Obtención de clave privada}
Cuando un usuario del sistema quiere solicitar su clave privada, se realiza el siguiente computo.\\
Dada su $ID \in \lbrace 0,1 \rbrace^*$ calculamos $Q_{ID}=H_1(ID)\in G^*_1$ y tomamos $d_{ID}$ como la clave privada de la forma $d_{ID} = sQ_{ID}$.

\subsection{Cifrado}
Sea el mensaje $M\in \cal{M}$, para poder cifrarlo en primer lugar se calcula la clave pública del destinatario, para ello se computa $Q_{ID}=H_1(ID)\in G^*_1$, se elige al azar $r\in \mathbb{Z}^*_q$, el texto cifrado sería:\\
\[
C = \langle rP, M \oplus H_2(g^r_{ID})\rangle
\]
donde $ g^r_{ID} = e(Q_{ID}, P_{pub}) \in G_2$

\subsection{Descifrado}
Sea el mensaje cifrado $C = \langle U,V \rangle \in \cal{C}$ que ha sido computado con la clave pública usando la identidad $ID$. Para descifrar el mensaje usando la clave privada $d_{ID}\in G^*_1$ y obtener el mensaje original $M$ tenemos que computar:
\[
M = V \oplus H_2(e(d_{ID}, U))
\]


\underline{Demostración}: Corrección del esquema.\\
Se quiere demostrar que $M = V \oplus H_2(e(d_{ID}, U))$ .\\
Para demostrar que el mecanismo de cifrar y descifrar efectivamente es correcto, hay que probar que el mensaje original puede obtenerse descifrando el mensaje cifrado. Para ello se debe usar la propiedad de bilinearidad del emparejamiento.
\[
\begin{split}
V \oplus H_2(e(d_{ID}, U)) &= V \oplus H_2(e(sQ_{ID}, rP))\\
&= V \oplus H_2(e(Q_{ID}, P)^{rs})\\
&= V \oplus H_2(e(Q_{ID}, sP)^r)\\
&= V \oplus H_2(e(Q_{ID}, P_{pub})^r)\\
&= V \oplus H_2(g^r_{ID})\\
&= M \oplus H_2(g^r_{ID}) \oplus H_2(g^r_{ID})\\
&= M
\end{split}
\]\\

\section{Consideraciones sobre el esquema}
\begin{itemize}
\item La clave maestra es un punto crítico del sistema, ya que si alguien es capaz de conseguirla podrá obtener todas las claves privadas de los usuarios del sistema.
\item Si se rompe una clave privada se podrían descifrar todos los mensajes anteriores cifrados con la clave publica correspondiente.
\item Para una clave privada comprometida es imposible generar una nueva asociada a esa ID.
\item Si se conoce desde el principio el número de participantes del sistema se puede eliminar el generador de claves privadas (PKG) una vez todos los usuarios conozcan la suya, eliminando unos de los posibles puntos de ataque.
\
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
En las últimas décadas los mecanismos criptográficos se han basado en dos problemas fundamentalmente, el logaritmo discreto que se ha tratado en este estudio y el problema de la factorización de números enteros. Aunque se consideren problemas difíciles en tiempo de cómputo y se haya planteado el algoritmo Baby-step/Giant-step de complejidad $\cal{O} $($\sqrt{p}$), esto no significa que no haya algoritmos mejores y que puedan comprometer en un futuro la seguridad de los sistemas basados en estos dos problemas. De hecho existen algoritmos en el paradigma de la computación cuántica capaces de resolver estos problemas con una menor complejidad como el algoritmo de Shor.\\
La seguridad de los sistemas una vez se implementan crean puntos de ataque que no están contemplados originalmente en el algoritmo, ya sea por la elección de los números primos, ataques de canal lateral o por las funciones hash elegidas. Por lo que un esquema que de forma teórica tiene buenos mecanismos de seguridad puede ser vulnerable cuando se lleva a la practica.\\
Este trabajo me ha aportado los fundamentos necesarios para entender el razonamiento detrás de algunos esquemas de cifrado y firma digital, permitiéndome llevar los conceptos teóricos desarrollados en el grado hacia una utilidad real de las matemáticas, además de esto me ha permitido comprender los problemas que enfrentan fuera del ámbito académico los matemáticos que en el caso de este estudio lograron combinar las ramas de álgebra y geometría de una manera ingeniosa para dar lugar a un grupo que no es nada obvio.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\nocite{*}
\bibliographystyle{abbrv}
\bibliography{memoria} % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/




\cleardoublepage
\chapter{Anexo: Representación de curvas elípticas}
Durante mi estudio quería comprender y verificar que las fórmulas que se plantean para la ley de grupo de las curvas elípticas se contrastaban con la idea geométrica de la suma de puntos, por lo que desarrollé el siguiente código que permite representar una curva en el plano afín partiendo de los parámetros $a$ y $b$ de la forma corta de Weierstrass de la curva, así como incorporar puntos a partir de la coordenada $x$ y el signo del punto, para posteriormente poder computar la suma y representarlo como se puede ver en la figura \ref{Suma de puntos}
\begin{verbatim}
import numpy as np
import math
import matplotlib.pyplot as plt 
# Siempre en la forma corta de Weierstrass
class curva: 
    a = -1
    b = 1
    #lista de diccionarios {nombre,x,signo,[color]}
    puntos = []
    def __init__(self,a,b):
        self.a=a
        self.b=b
    def dibuja(self):
        y, x = np.ogrid[-5:5:100j, -5:5:100j]
        plt.contour(x.ravel(), y.ravel(), pow(y, 2) - pow(x, 3)\
        						 - x * self.a - self.b, [0]) 
        plt.grid()
        
    def figura(self):
        plt.show()
        
    def limpiar_p(self):
        self.puntos=[]
    def add_p(self,punto):
        self.puntos.append(punto)
    def dibuja_p(self):
        X=[punto['x'] for punto in self.puntos]
        Y=[self.calcula_y(punto) for punto in self.puntos]
        colors=[punto['color'] if 'color' in punto.keys()\
        				 else 'purple' for punto in self.puntos]
        plt.scatter(X,Y,c=colors,s=100)
        
    def calcula_y(self,punto):
        return punto['signo']*math.sqrt(pow(punto['x'], 3)\
        				 + punto['x'] * self.a + self.b)
    
    def suma_p(self,nombre1,nombre2):
        A=next(item for item in self.puntos\
        		 if item["nombre"] == nombre1)
        B=next(item for item in self.puntos\
        		 if item["nombre"] == nombre2)
        A_x=A['x']
        A_y=self.calcula_y(A)
        B_x=B['x']
        B_y=self.calcula_y(B)
        if A_x != B_x:
            lamda=(B_y-A_y)/(B_x-A_x)
            mu=(A_y*B_x-B_y*A_x)/(B_x-A_x)
        elif A_x == B_x and A_y != B_y:
            lamda=(3*pow(A_x,2)+self.a)/(2*A_y)
            mu=(-pow(A_x,3)+self.a*A_x+2*self.b)/(2*A_y)
        else:
            return {'nombre':'inf'}
        P_x=pow(lamda,2)-A_x-B_x
        P_y=-lamda*P_x-mu
        punto = {'nombre':'%s + %s'%(nombre1,nombre2),'x':P_x,\
        		 'signo':1 if P_y>=0 else -1}
        return punto
    
    #El primer punto debe tener menor x
    def dibuja_suma_p(self,nombre1,nombre2):
        A=next(item for item in self.puntos\
        		 if item["nombre"] == nombre1)
        B=next(item for item in self.puntos\
        		 if item["nombre"] == nombre2)
        suma=self.suma_p(nombre1,nombre2)
        y_init=self.calcula_y(A) if min(A['x'],suma['x'])==A['x']\
        						 else -self.calcula_y(suma)
        y_fin=self.calcula_y(B) if max(B['x'],suma['x'])==B['x']\
        						else -self.calcula_y(suma)
        plt.plot([min(A['x'],suma['x']),\
        			max(B['x'],suma['x'])], [y_init,y_fin], 'r-')
        plt.axvline(x=suma['x'],c='purple')
        
    def guarda_plot(directorio="",nombre="Curva",extension="png"):
        plt.savefig("%s%s.%s"%(directorio+"/"if directorio!=""\
        					 else "",nombre,extension),dpi=400)
\end{verbatim}



\end{document}